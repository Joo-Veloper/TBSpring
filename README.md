#### 오브젝트와 클래스의 관계

**오브젝트**(객체)는 객체지향 프로그래밍(OOP, Object-Oriented Programming)의 핵심 개념입니다. 우리가 코딩할 때 만드는 것은 보통 클래스인데, 클래스는 오브젝트를 만들어내기 위한 설계도입니다. 클래스는 코드를 작성할 때 정의되지만, 오브젝트는 프로그램이 실행될 때 동적으로 생성되고 동작합니다.

#### 클래스와 오브젝트의 차이점

- **클래스**: 오브젝트를 만들기 위한 청사진. 예를 들어, 건물을 짓기 위한 설계도입니다. 클래스를 정의하면 그 안에 어떤 속성과 메서드가 포함될지를 명시합니다.
- **오브젝트**: 클래스의 인스턴스로, 프로그램이 실행될 때 생성되어 실제로 동작하는 존재. 건물의 설계도에 따라 실제로 지어진 건물입니다.

클래스를 작성하는 코드는 프로그램이 실행될 때 오브젝트로 변환되며, 이 오브젝트가 실제로 우리가 원하는 기능을 수행합니다.

#### 클래스의 인스턴스

클래스의 인스턴스는 오브젝트입니다. 인스턴스는 추상적인 클래스를 기반으로 실제로 만들어진 구체적인 실체를 의미합니다. 예를 들어, `House`라는 클래스가 있다면, 이 클래스로부터 만들어진 각각의 집들이 인스턴스입니다.

자바에서의 오브젝트는 클래스의 인스턴스 또는 배열입니다. 배열은 클래스 인스턴스는 아니지만 자바에서는 오브젝트로 취급됩니다.

**요약**:
- 클래스: 오브젝트를 정의하는 설계도
- 오브젝트: 클래스의 인스턴스, 실제로 프로그램이 실행될 때 동작하는 실체

### 의존 관계 (Dependency)

의존 관계는 하나의 오브젝트나 클래스가 다른 오브젝트나 클래스를 필요로 하는 관계를 말합니다. 의존 관계를 다이어그램으로 표현할 때, `A ---> B`는 A가 B에 의존하고 있다는 의미입니다.

#### 클래스 간의 의존 관계

클래스 간의 의존 관계는 코드 레벨에서 발생합니다. 클라이언트 클래스가 서플라이어 클래스를 사용하면, 클라이언트 클래스는 서플라이어 클래스에 의존한다고 말할 수 있습니다. 클라이언트 클래스 코드가 제대로 동작하려면 서플라이어 클래스 코드가 존재해야 합니다.

#### 오브젝트 간의 의존 관계

오브젝트 간의 의존 관계는 런타임에서 발생합니다. 프로그램 실행 중에 오브젝트가 다른 오브젝트에게 기능을 요청하거나 작업을 맡기는 경우, 이들 사이에 의존 관계가 형성됩니다. 이는 실제 프로그램이 실행되는 동안의 동적인 관계입니다.

#### 의존 관계의 영향

클라이언트 클래스가 서플라이어 클래스에 의존하면, 서플라이어 클래스가 변경될 때 클라이언트 클래스도 영향을 받을 수 있습니다. 이는 코드의 유지보수와 확장에 중요한 영향을 미칩니다.

**정리**:
- 클래스 간의 의존 관계: 코드 레벨에서 발생, 클라이언트 클래스가 서플라이어 클래스를 필요로 함
- 오브젝트 간의 의존 관계: 런타임에서 발생, 오브젝트가 다른 오브젝트의 기능을 필요로 함

스프링 프레임워크는 이러한 의존 관계를 관리하고 조절하는 데 중요한 역할을 합니다. 클래스와 오브젝트의 의존 관계를 효율적으로 관리하여 코드의 유연성과 재사용성을 높이는 것이 스프링의 핵심 원리 중 하나입니다.

---
#### 관심사 불리  SOC
1. 관심사(Concern)란 무엇인가?
   관심사란 소프트웨어 시스템에서 특정한 기능이나 역할을 의미합니다. 예를 들어, 데이터베이스 접근, 사용자 인터페이스, 비즈니스 로직 등은 각각의 관심사로 볼 수 있습니다.

2. 관심사 분리의 필요성
   - 이해와 유지보수 용이성: 각각의 관심사가 독립적으로 분리되어 있으면, 코드를 이해하고 수정하는 것이 쉬워집니다.
   - 모듈성: 각 관심사를 모듈로 나누면, 특정 기능을 수정하거나 교체할 때 다른 부분에 영향을 주지 않고 작업할 수 있습니다.
   - 재사용성: 분리된 모듈은 다른 프로젝트에서도 쉽게 재사용할 수 있습니다.
   - 테스트 용이성: 개별 모듈을 독립적으로 테스트할 수 있어 테스트가 더 쉽고 철저하게 수행될 수 있습니다.
3. 관심사 분리 구현 방법
   - 레이어드 아키텍처(Layered Architecture): 시스템을 여러 계층으로 나누어 각 계층이 서로 다른 관심사를 처리합니다. 예를 들어, 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 접근 계층 등이 있습니다.
   - 모듈화(Modularity): 관련 기능을 묶어 모듈을 만들고, 각 모듈이 독립적으로 동작하게 합니다.
   - MVC 패턴(Model-View-Controller): 애플리케이션을 모델, 뷰, 컨트롤러로 나누어 관심사를 분리합니다. 모델은 데이터와 비즈니스 로직을, 뷰는 사용자 인터페이스를, 컨트롤러는 사용자 입력을 처리합니다.
   - 서비스 지향 아키텍처(SOA) 및 마이크로서비스: 시스템을 독립적인 서비스로 분리하여 각 서비스가 독립적으로 개발, 배포, 유지보수될 수 있게 합니다.
4. 관심사 분리의 사례
   - 웹 애플리케이션: 프론트엔드와 백엔드를 분리하여 프론트엔드는 사용자 인터페이스를 담당하고, 백엔드는 데이터 처리 및 비즈니스 로직을 담당합니다.
   - 데이터베이스 접근: 데이터베이스 접근 코드를 별도의 레이어나 모듈로 분리하여 비즈니스 로직과 데이터 접근 로직이 섞이지 않도록 합니다.
   - 로그 관리: 애플리케이션 로깅을 별도의 모듈이나 서비스로 분리하여 주요 비즈니스 로직과 로그 관리 로직이 독립적으로 동작하도록 합니다.
5. 관심사 분리의 이점
   - 코드의 가독성 향상: 분리된 각 모듈이나 계층은 명확한 역할을 가지므로 코드가 더 읽기 쉬워집니다.
   - 변경 용이성: 한 부분의 변경이 다른 부분에 영향을 미치지 않으므로, 변경 작업이 더 쉬워집니다.
   - 협업 효율성 향상: 팀원들이 서로 다른 모듈이나 계층을 독립적으로 작업할 수 있어 개발 효율성이 높아집니다.
   - 버그 감소: 모듈화된 시스템에서는 버그가 발생할 수 있는 범위가 제한적이므로 버그의 발견과 수정이 더 쉽습니다.
---
### 원칙과 패턴

#### 개방 폐쇄 원칙 (Open-Closed Principle, OCP)
- **정의**: 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
- **설명**: 소프트웨어 시스템은 새로운 기능을 추가할 때 기존 코드를 변경하지 않고도 기능을 확장할 수 있어야 한다. 즉, 코드를 재작성하지 않고도 기능을 추가할 수 있도록 설계해야 한다.
- **예시**: 새로운 기능을 추가하기 위해 기존 클래스를 수정하는 대신, 해당 클래스를 상속하거나 인터페이스를 구현하는 방식으로 새로운 클래스를 작성하여 기능을 확장한다.

#### 높은 응집도와 낮은 결합도
- **응집도**: 모듈 내의 구성 요소들이 얼마나 밀접하게 관련되어 있는지를 나타낸다.
   - **높은 응집도**: 모듈이 하나의 책임 또는 관심사에 집중되어 있어 변화가 일어날 때 모듈 내의 변경 범위가 작다. 코드 이해와 유지보수가 용이하며, 변화에 대한 비용이 적다.
- **결합도**: 모듈 간의 상호 의존성을 나타낸다.
   - **낮은 결합도**: 모듈 간의 의존성을 최소화하여 변화가 한 모듈에서 발생해도 다른 모듈에 미치는 영향을 줄인다. 코드 수정 시 영향을 받는 부분이 적어 유지보수가 용이하다.
- **설명**: 높은 응집도와 낮은 결합도를 유지함으로써 시스템의 모듈들이 독립적이고 변화에 강하며 유지보수하기 쉽게 만든다.

#### 전략 패턴 (Strategy Pattern)
- **정의**: 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리하고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔 사용할 수 있게 하는 디자인 패턴.
- **설명**: 동일한 작업을 수행하는 여러 알고리즘을 정의하고, 클라이언트 코드에서 알고리즘을 선택하여 사용할 수 있도록 한다. 알고리즘을 정의하는 인터페이스와 이를 구현하는 구체적인 클래스로 구성된다.
- **예시**: 정렬 알고리즘을 사용하는 경우, 다양한 정렬 알고리즘(버블 정렬, 퀵 정렬 등)을 각각의 클래스에서 구현하고, 필요에 따라 클라이언트 코드에서 적절한 정렬 알고리즘을 선택하여 사용한다.

#### 제어의 역전 (Inversion of Control, IoC)
- **정의**: 제어권을 클라이언트에서 프레임워크나 컨테이너로 이전하여 제어 관계를 역전시키는 원리.
- **설명**: 클라이언트 코드가 흐름을 제어하는 대신, 프레임워크나 컨테이너가 흐름을 제어하여 클라이언트 코드의 의존성을 줄이고, 시스템의 유연성과 확장성을 높인다.
- **예시**: 스프링 프레임워크에서의 의존성 주입(Dependency Injection)은 IoC의 대표적인 예로, 객체 생성과 의존성 관리를 프레임워크가 담당한다.