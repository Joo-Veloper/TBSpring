## 오브젝트와 클래스의 관계

**오브젝트**(객체)는 객체지향 프로그래밍(OOP, Object-Oriented Programming)의 핵심 개념입니다. 우리가 코딩할 때 만드는 것은 보통 클래스인데, 클래스는 오브젝트를 만들어내기 위한 설계도입니다. 클래스는 코드를 작성할 때 정의되지만, 오브젝트는 프로그램이 실행될 때 동적으로 생성되고 동작합니다.

## 클래스와 오브젝트의 차이점

- **클래스**: 오브젝트를 만들기 위한 청사진. 예를 들어, 건물을 짓기 위한 설계도입니다. 클래스를 정의하면 그 안에 어떤 속성과 메서드가 포함될지를 명시합니다.
- **오브젝트**: 클래스의 인스턴스로, 프로그램이 실행될 때 생성되어 실제로 동작하는 존재. 건물의 설계도에 따라 실제로 지어진 건물입니다.

클래스를 작성하는 코드는 프로그램이 실행될 때 오브젝트로 변환되며, 이 오브젝트가 실제로 우리가 원하는 기능을 수행합니다.

## 클래스의 인스턴스

클래스의 인스턴스는 오브젝트입니다. 인스턴스는 추상적인 클래스를 기반으로 실제로 만들어진 구체적인 실체를 의미합니다. 예를 들어, `House`라는 클래스가 있다면, 이 클래스로부터 만들어진 각각의 집들이 인스턴스입니다.

자바에서의 오브젝트는 클래스의 인스턴스 또는 배열입니다. 배열은 클래스 인스턴스는 아니지만 자바에서는 오브젝트로 취급됩니다.

**요약**:
- 클래스: 오브젝트를 정의하는 설계도
- 오브젝트: 클래스의 인스턴스, 실제로 프로그램이 실행될 때 동작하는 실체

## 의존 관계 (Dependency)

의존 관계는 하나의 오브젝트나 클래스가 다른 오브젝트나 클래스를 필요로 하는 관계를 말합니다. 의존 관계를 다이어그램으로 표현할 때, `A ---> B`는 A가 B에 의존하고 있다는 의미입니다.

## 클래스 간의 의존 관계

클래스 간의 의존 관계는 코드 레벨에서 발생합니다. 클라이언트 클래스가 서플라이어 클래스를 사용하면, 클라이언트 클래스는 서플라이어 클래스에 의존한다고 말할 수 있습니다. 클라이언트 클래스 코드가 제대로 동작하려면 서플라이어 클래스 코드가 존재해야 합니다.

## 오브젝트 간의 의존 관계

오브젝트 간의 의존 관계는 런타임에서 발생합니다. 프로그램 실행 중에 오브젝트가 다른 오브젝트에게 기능을 요청하거나 작업을 맡기는 경우, 이들 사이에 의존 관계가 형성됩니다. 이는 실제 프로그램이 실행되는 동안의 동적인 관계입니다.

## 의존 관계의 영향

클라이언트 클래스가 서플라이어 클래스에 의존하면, 서플라이어 클래스가 변경될 때 클라이언트 클래스도 영향을 받을 수 있습니다. 이는 코드의 유지보수와 확장에 중요한 영향을 미칩니다.

**정리**:
- 클래스 간의 의존 관계: 코드 레벨에서 발생, 클라이언트 클래스가 서플라이어 클래스를 필요로 함
- 오브젝트 간의 의존 관계: 런타임에서 발생, 오브젝트가 다른 오브젝트의 기능을 필요로 함

스프링 프레임워크는 이러한 의존 관계를 관리하고 조절하는 데 중요한 역할을 합니다. 클래스와 오브젝트의 의존 관계를 효율적으로 관리하여 코드의 유연성과 재사용성을 높이는 것이 스프링의 핵심 원리 중 하나입니다.

---
## 관심사 불리  SOC
1. 관심사(Concern)란 무엇인가?
   관심사란 소프트웨어 시스템에서 특정한 기능이나 역할을 의미합니다. 예를 들어, 데이터베이스 접근, 사용자 인터페이스, 비즈니스 로직 등은 각각의 관심사로 볼 수 있습니다.

2. 관심사 분리의 필요성
   - 이해와 유지보수 용이성: 각각의 관심사가 독립적으로 분리되어 있으면, 코드를 이해하고 수정하는 것이 쉬워집니다.
   - 모듈성: 각 관심사를 모듈로 나누면, 특정 기능을 수정하거나 교체할 때 다른 부분에 영향을 주지 않고 작업할 수 있습니다.
   - 재사용성: 분리된 모듈은 다른 프로젝트에서도 쉽게 재사용할 수 있습니다.
   - 테스트 용이성: 개별 모듈을 독립적으로 테스트할 수 있어 테스트가 더 쉽고 철저하게 수행될 수 있습니다.
3. 관심사 분리 구현 방법
   - 레이어드 아키텍처(Layered Architecture): 시스템을 여러 계층으로 나누어 각 계층이 서로 다른 관심사를 처리합니다. 예를 들어, 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 접근 계층 등이 있습니다.
   - 모듈화(Modularity): 관련 기능을 묶어 모듈을 만들고, 각 모듈이 독립적으로 동작하게 합니다.
   - MVC 패턴(Model-View-Controller): 애플리케이션을 모델, 뷰, 컨트롤러로 나누어 관심사를 분리합니다. 모델은 데이터와 비즈니스 로직을, 뷰는 사용자 인터페이스를, 컨트롤러는 사용자 입력을 처리합니다.
   - 서비스 지향 아키텍처(SOA) 및 마이크로서비스: 시스템을 독립적인 서비스로 분리하여 각 서비스가 독립적으로 개발, 배포, 유지보수될 수 있게 합니다.
4. 관심사 분리의 사례
   - 웹 애플리케이션: 프론트엔드와 백엔드를 분리하여 프론트엔드는 사용자 인터페이스를 담당하고, 백엔드는 데이터 처리 및 비즈니스 로직을 담당합니다.
   - 데이터베이스 접근: 데이터베이스 접근 코드를 별도의 레이어나 모듈로 분리하여 비즈니스 로직과 데이터 접근 로직이 섞이지 않도록 합니다.
   - 로그 관리: 애플리케이션 로깅을 별도의 모듈이나 서비스로 분리하여 주요 비즈니스 로직과 로그 관리 로직이 독립적으로 동작하도록 합니다.
5. 관심사 분리의 이점
   - 코드의 가독성 향상: 분리된 각 모듈이나 계층은 명확한 역할을 가지므로 코드가 더 읽기 쉬워집니다.
   - 변경 용이성: 한 부분의 변경이 다른 부분에 영향을 미치지 않으므로, 변경 작업이 더 쉬워집니다.
   - 협업 효율성 향상: 팀원들이 서로 다른 모듈이나 계층을 독립적으로 작업할 수 있어 개발 효율성이 높아집니다.
   - 버그 감소: 모듈화된 시스템에서는 버그가 발생할 수 있는 범위가 제한적이므로 버그의 발견과 수정이 더 쉽습니다.
---
# 원칙과 패턴

## 개방 폐쇄 원칙 (Open-Closed Principle, OCP)
- **정의**: 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
- **설명**: 소프트웨어 시스템은 새로운 기능을 추가할 때 기존 코드를 변경하지 않고도 기능을 확장할 수 있어야 한다. 즉, 코드를 재작성하지 않고도 기능을 추가할 수 있도록 설계해야 한다.
- **예시**: 새로운 기능을 추가하기 위해 기존 클래스를 수정하는 대신, 해당 클래스를 상속하거나 인터페이스를 구현하는 방식으로 새로운 클래스를 작성하여 기능을 확장한다.

## 높은 응집도와 낮은 결합도
- **응집도**: 모듈 내의 구성 요소들이 얼마나 밀접하게 관련되어 있는지를 나타낸다.
   - **높은 응집도**: 모듈이 하나의 책임 또는 관심사에 집중되어 있어 변화가 일어날 때 모듈 내의 변경 범위가 작다. 코드 이해와 유지보수가 용이하며, 변화에 대한 비용이 적다.
- **결합도**: 모듈 간의 상호 의존성을 나타낸다.
   - **낮은 결합도**: 모듈 간의 의존성을 최소화하여 변화가 한 모듈에서 발생해도 다른 모듈에 미치는 영향을 줄인다. 코드 수정 시 영향을 받는 부분이 적어 유지보수가 용이하다.
- **설명**: 높은 응집도와 낮은 결합도를 유지함으로써 시스템의 모듈들이 독립적이고 변화에 강하며 유지보수하기 쉽게 만든다.

## 전략 패턴 (Strategy Pattern)
- **정의**: 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리하고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔 사용할 수 있게 하는 디자인 패턴.
- **설명**: 동일한 작업을 수행하는 여러 알고리즘을 정의하고, 클라이언트 코드에서 알고리즘을 선택하여 사용할 수 있도록 한다. 알고리즘을 정의하는 인터페이스와 이를 구현하는 구체적인 클래스로 구성된다.
- **예시**: 정렬 알고리즘을 사용하는 경우, 다양한 정렬 알고리즘(버블 정렬, 퀵 정렬 등)을 각각의 클래스에서 구현하고, 필요에 따라 클라이언트 코드에서 적절한 정렬 알고리즘을 선택하여 사용한다.

## 제어의 역전 (Inversion of Control, IoC)
- **정의**: 제어권을 클라이언트에서 프레임워크나 컨테이너로 이전하여 제어 관계를 역전시키는 원리.
- **설명**: 클라이언트 코드가 흐름을 제어하는 대신, 프레임워크나 컨테이너가 흐름을 제어하여 클라이언트 코드의 의존성을 줄이고, 시스템의 유연성과 확장성을 높인다.
- **예시**: 스프링 프레임워크에서의 의존성 주입(Dependency Injection)은 IoC의 대표적인 예로, 객체 생성과 의존성 관리를 프레임워크가 담당한다.

---

## 싱글톤 레지스트리

싱글톤 레지스트리는 스프링 프레임워크에서 사용되는 개념으로, 스프링이 관리하는 객체들을 싱글톤으로 관리하고, 필요할 때마다 이들 객체를 제공하는 메커니즘을 말합니다. 이를 통해 애플리케이션에서 필요한 객체들을 중앙 집중적으로 관리하고, 재사용할 수 있습니다.</br>

싱글톤 레지스트리의 주요 특징과 이점은 다음과 같습니다:</br>

중앙 집중적인 객체 관리: 스프링 컨테이너가 모든 빈(bean) 객체를 싱글톤으로 관리합니다. 이는 스프링이 애플리케이션에서 하나의 인스턴스만 생성하여 사용하며, 이를 필요로 하는 다른 객체들에게 공유합니다.</br>
의존성 관리: 스프링은 빈 객체들 간의 의존성을 주입(Dependency Injection)을 통해 관리합니다. 이로 인해 개발자는 객체 생성과 초기화에 집중하지 않고도 의존성을 손쉽게 처리할 수 있습니다.</br>

성능 향상: 반복적인 객체 생성을 피하고, 필요할 때마다 동일한 인스턴스를 재사용함으로써 성능을 향상시킵니다.</br>

코드 간결성: 스프링의 IoC (Inversion of Control) 컨셉에 따라 개발자는 객체의 생성 및 관리를 위한 코드를 작성하지 않아도 됩니다. 대신, 스프링 설정 파일에서 빈 객체들을 선언하고 필요한 곳에서 주입받아 사용할 수 있습니다.</br>

유연성과 확장성: 스프링의 빈 객체는 설정 파일에서 쉽게 변경하고 확장할 수 있습니다. 이는 애플리케이션의 요구 사항이나 환경 변화에 따라 빠르게 대응할 수 있게 해줍니다.</br>

싱글톤 레지스트리는 스프링의 핵심 기능 중 하나로, 객체 지향적 설계와 코드의 재사용성, 유지보수성을 높이는 데 중요한 역할을 합니다.</br>

## DI 와 디자인 패턴
디자인 패턴은 목적에 따라 분류할 수 있고, 스코프에 따라 클래스 패턴과 오브젝트 패턴으로 나눌 수 있습니다.</br>

1. **클래스 패턴**:
   - 상속을 이용하여 구조를 정의합니다.
   - 예시: 템플릿 메서드 패턴
   - 컴파일 타임에 관계를 정의합니다.

2. **오브젝트 패턴**:
   - 합성을 이용하여 구조를 정의합니다.
   - 예시: 전략 패턴, 데코레이터 패턴
   - 런타임에 관계를 설정합니다.
   - 대부분의 디자인 패턴은 여기에 속합니다.

오브젝트 패턴을 효과적으로 사용하려면 **의존관계 주입 (Dependency Injection, DI)**이 필요합니다. DI는 런타임에 오브젝트 간의 관계를 설정하고 관리합니다.</br>

특히 스프링(SPRING) 프레임워크를 사용하면 DI를 쉽게 적용할 수 있습니다. 스프링 컨테이너는 객체 생성과 의존관계 설정을 자동으로 처리합니다.</br>

따라서, 오브젝트 합성을 이용한 디자인 패턴을 적용하려면 스프링의 DI를 사용하면 됩니다. DI는 디자인 패턴을 효과적으로 활용할 수 있게 도와줍니다.</br>

## 데코레이터 디자인 패턴
데코레이터 패턴은 기존 코드의 수정을 피하면서 오브젝트에 부가적인 기능을 동적으로 추가하는 방법입니다. 즉, 기능을 업데이트하려면 코드를 수정해야 한다는 고정 관념을 벗어나, 데코레이터 패턴을 통해 유연하게 기능을 확장할 수 있습니다.</br>

## 의존성 역전 원칙 (DIP)
의존성 역전 원칙은 소프트웨어 설계에서 중요한 원칙으로, 모듈 간의 의존성을 효과적으로 관리하는 방법을 제시합니다.</br>

1. **상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다.**
   - 상위 수준 모듈과 하위 수준 모듈 모두 추상화(인터페이스나 추상 클래스)에 의존해야 하며, 구체적인 구현에 의존하지 않아야 합니다.</br>

2. **추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.**
   - 구체적인 구현 클래스는 추상화된 인터페이스나 추상 클래스를 구현하거나 상속해야 합니다. 이를 통해 시스템의 유연성과 재사용성을 높일 수 있습니다.</br>

### 모듈
모듈은 전체 소프트웨어 시스템을 작은 단위로 나눈 것으로, 응집도가 높고 결합도가 낮은 단위로 설계합니다. 모듈 간에는 느슨한 결합을 유지하면서 내부적으로는 강한 응집력을 갖습니다.</br>

- **예시**: 자바 프로젝트의 JAR 파일, 패키지 등은 모듈의 한 예입니다. 패키지를 사용하여 관련 있는 클래스와 인터페이스를 그룹화함으로써 모듈을 구분할 수 있습니다.</br>
